#ifndef PLAYER_H
#define PLAYER_H

#include "asset_holder.h"
#include "define.h"

////////////////////////////////////////////////////////////
/// \brief class dealing with player movement,collision and markers
///
/// this class handles player movement ,collision and placement
/// of collectable markers which serve as victory condition
///
////////////////////////////////////////////////////////////
class player
{
private:

	enum class move_dir_no { MOVE_NULL, MOVE_LEFT, MOVE_RIGHT, MOVE_DOWN, MOVE_UP };

	////////////////////////////////////////////////////////////
	/// \brief size of player
	///
	////////////////////////////////////////////////////////////
	float BASE_SIZE = PLAYER_BASE_SIZE;

	//movement variables
	////////////////////////////////////////////////////////////
	/// \brief denotes if player moving or not
	///  
	/// false denotes player is stationary and 
	/// true denotes player is moving
	///
	////////////////////////////////////////////////////////////
	bool moving;

	////////////////////////////////////////////////////////////
	/// \brief denotes movement direction
	///
	////////////////////////////////////////////////////////////
	move_dir_no movedirection;

	////////////////////////////////////////////////////////////
	/// \brief used to initialize variables
	///
	/// sets movementspeed to required value and
	/// sets movement variables moving and move direction to initial values
	///
	////////////////////////////////////////////////////////////
	void initvariables();

	////////////////////////////////////////////////////////////
	/// \brief used to initialize player shape
	///
	/// initializes size and color of player shape
	////////////////////////////////////////////////////////////
	const void initshape();

	////////////////////////////////////////////////////////////
	/// \brief denotes player movement speed
	///
	////////////////////////////////////////////////////////////
	float movementspeed;

	////////////////////////////////////////////////////////////
	/// \brief used to indicate if grid has been colored
	///
	/// true when grid colored entirely,false otherwise
	///
	////////////////////////////////////////////////////////////
	bool all_grids_colored;

	////////////////////////////////////////////////////////////
	/// \brief used to make sure grid entirely covered
	///
	/// used in updatemarkers() to ensure last bit of movement 
	////////////////////////////////////////////////////////////
	bool end_flag;

	//vector where all markers are stored
	////////////////////////////////////////////////////////////
	/// \brief storage for all markers
	///
	////////////////////////////////////////////////////////////
	std::vector<sf::RectangleShape> markers;

	////////////////////////////////////////////////////////////
	/// \brief temporary marker object
	///
	/// used to set size,color,origin of all markers
	////////////////////////////////////////////////////////////
	sf::RectangleShape marker_temp;

	////////////////////////////////////////////////////////////
	/// \brief used to ensure proper level completion
	///
    /// Used to make sure player moves certain distance after 
	/// collecting all markers before stopping so that entire 
	/// grid is colored 
	///
	////////////////////////////////////////////////////////////
	std::pair<sf::Vector2f, sf::Vector2f> ending_movement;

    //variables needed for time independent implementation

	////////////////////////////////////////////////////////////
	/// \brief denotes delta time
	///
	////////////////////////////////////////////////////////////
	float dt;

	////////////////////////////////////////////////////////////
	/// \brief denotes frame rate to be acheived
	///
	////////////////////////////////////////////////////////////
	float time_mult;

	//needed to draw trail lines

	//vector where all previously made trails are stored
	////////////////////////////////////////////////////////////
	/// \brief storage for all previously drawn trails
	///
	////////////////////////////////////////////////////////////
	std::vector<sf::RectangleShape> trails;

	////////////////////////////////////////////////////////////
	/// \brief denotes start of the trail being drawn
	///
	////////////////////////////////////////////////////////////
	sf::Vector2f start_trail;

	////////////////////////////////////////////////////////////
	/// \brief denotes end of trail at that moment
	///
	////////////////////////////////////////////////////////////
	sf::Vector2f end_trail;

	//shape which is for trail being drawn(if any)
	////////////////////////////////////////////////////////////
	/// \brief returns a trail given 2 points
	/// 
	////////////////////////////////////////////////////////////
	sf::RectangleShape curr_trail(sf::Vector2f* start, sf::Vector2f* end);

	//sets trail start depending on movement direction
	////////////////////////////////////////////////////////////
	/// \brief sets start_trail to where start of trail is, given movement direction
	///
	///  this function should only be called when movement happening 
	///  will not change start_trail variable otherwise
	/// 
	////////////////////////////////////////////////////////////
	void get_start_trail(move_dir_no, sf::FloatRect);

	//sets trail end depending on movement direction
	////////////////////////////////////////////////////////////
	/// \brief setsend_trail to where end of trail is,given movement direction
	///
	///  this function should only be called when movement happening 
	///  will not change end_trail variable otherwise
	/// 
	////////////////////////////////////////////////////////////
	void get_end_trail(move_dir_no,sf::FloatRect);

	//updates input and movement
	////////////////////////////////////////////////////////////
	/// \brief checks input,sets movement,changes start_trail accordingly
	///
	/// this function checks the input to see if movement
	/// key pressed ,changes movement accordingly and
	/// assigns a valid value to start-trail for given movement
	///
	////////////////////////////////////////////////////////////
	void update_input_and_movement();

	//checks for window collison 
	////////////////////////////////////////////////////////////
	/// \brief ensures player remains within screen 
	///
	///  checks if player is touching/out of screen and
	/// adjusts it's position and stops movement accordingly 
	///
	/// \param target pointer to window with which bounds is to be checked
	///
	////////////////////////////////////////////////////////////
	void updatewindowcollision(sf::RenderTarget* target);

	////////////////////////////////////////////////////////////
	/// \brief checks for collision with given object 
	///
	///  checks if player is colliding with object and
	/// adjusts it's position and stops movement accordingly
	///
	/// \param object pointer to object with which collision is to be checked
	///
	////////////////////////////////////////////////////////////
	void updatemarkers();

	////////////////////////////////////////////////////////////
	/// \brief stores direction in which player was most recently
	/// moving(apart from MOVE_NULL) ,same as movement_direction
	/// when it is not equal to MOVE_NULL
	///
	////////////////////////////////////////////////////////////
	move_dir_no last_moving_direction;

	////////////////////////////////////////////////////////////
	/// \brief stores moving from last update cycle
	/// 
	////////////////////////////////////////////////////////////
	bool previous_moving;

	////////////////////////////////////////////////////////////
	/// \brief stores reference to asset_holder being used in 
	/// the game
	///
	////////////////////////////////////////////////////////////
	asset_holder& m_assets;

	////////////////////////////////////////////////////////////
	/// \brief sprite which shows player texture and animations
	///
	////////////////////////////////////////////////////////////
	sf::Sprite player_sprite;

	////////////////////////////////////////////////////////////
	/// \brief array of IntRect 's used on texture to get animations and set
	/// appropriate player textures
	///
	////////////////////////////////////////////////////////////
	sf::IntRect display_frame[6];

	////////////////////////////////////////////////////////////
	/// \brief  updaates player animation
	///
	////////////////////////////////////////////////////////////
	void update_animation(float _dt);
    
	////////////////////////////////////////////////////////////
	/// \brief  float for stationary animation
	///
	////////////////////////////////////////////////////////////
	float anim_timer;

	////////////////////////////////////////////////////////////
	/// \brief  float for moving animation
	///
	////////////////////////////////////////////////////////////
	float trail_timer;

	////////////////////////////////////////////////////////////
	/// \brief  int used to cycle stationary animation
	///
	////////////////////////////////////////////////////////////
	int anim_dir;

	////////////////////////////////////////////////////////////
	/// \brief  flag used by spring to indicate bounce
	///
	////////////////////////////////////////////////////////////
	bool spring_flag;

	////////////////////////////////////////////////////////////
	/// \brief  flag to play death animation and declare 
	/// player dead 
	///
	////////////////////////////////////////////////////////////
	bool dead;
public:

	friend class teleporter;
	friend class spring;

	////////////////////////////////////////////////////////////
	/// \brief bool to display markers
	///
	/// if set to true ,markers are displayed otherwise 
	/// not displayed
	///
	////////////////////////////////////////////////////////////
	bool display_markers;

	////////////////////////////////////////////////////////////
	/// \brief used to check if level completed
	///
	/// if returns true means that all markers were collected
	/// and level has finished(grid has been colored entirely),
	/// false means still some squares uncolored
	///
	/// \return bool showing if level complete
	///
	////////////////////////////////////////////////////////////
	bool level_complete();

	////////////////////////////////////////////////////////////
	/// \brief used to add markers in chain fashion
	///
	/// enter a vector of sf::Vector2f points in player units
	/// and this function will create markers with spacing in the 
	/// x and/or y direction  equal to player length between 
	/// consecutive points in vector
	///
	/// \param points std::vector<sf::Vector2f> vector of sf::vector2f points
	///
	/// \note place markers in middle of grid squares
	/// 
	/// \warning no output/change if only zero or one point in vector
	///
	/// \warning if 2 consecutive points are the same 
	/// then a single marker will be generated at that position
	///
	////////////////////////////////////////////////////////////
	void add_marker_chain(const std::vector<sf::Vector2f>& points);

	////////////////////////////////////////////////////////////
	/// \brief used to add a single marker
	///
	/// enter coordinates of marker in player length units 
	/// to generate a marker at that position 
	///
	/// \param pos sf::Vector2f position of point
	///
	/// \note place markers in middle of grid squares
	/// 
	////////////////////////////////////////////////////////////
	void add_marker_single(sf::Vector2f &pos);

	//cons and decons
	////////////////////////////////////////////////////////////
	/// \brief constructor
	///
	/// \param assets asset_holder* pointer to game's asset holder
	///
	/// \note Assign Player position as (0,0)
	/// 
	///
	////////////////////////////////////////////////////////////
	player(asset_holder* assets);

	////////////////////////////////////////////////////////////
	/// \brief destructor
	///
	////////////////////////////////////////////////////////////
	virtual ~player();

	////////////////////////////////////////////////////////////
	///	\brief SEt the position of the Player to the argument provided
	///	
	///	\param position sf::Vector2u position of Player in BASE SIZE coordinates
	///	
	///	\note use only at the initalising level or level changing
	///	
	////////////////////////////////////////////////////////////
	void setPosition(const sf::Vector2u position);

	////////////////////////////////////////////////////////////
	/// \brief plays dead animation
	///
	////////////////////////////////////////////////////////////
	void set_player_dead();
	
	////////////////////////////////////////////////////////////
	/// \brief used for square shaped player
	///
	////////////////////////////////////////////////////////////
	sf::RectangleShape shape;

	//returns coord of player object
	////////////////////////////////////////////////////////////
	/// \brief gives player coordinates
	///
	/// \return sf::vector2f showing x and y coordinates of player
	///
	////////////////////////////////////////////////////////////
	sf::Vector2f getcoord();

	////////////////////////////////////////////////////////////
	/// \brief checks for collision with given object 
	///
	///  checks if player is colliding with object and
	/// adjusts it's position and stops movement accordingly
	///
	/// \param object pointer to object with which collision is to be checked
	///
	////////////////////////////////////////////////////////////
	void update_collision(sf::RectangleShape* object);

	//generic update and vender
	////////////////////////////////////////////////////////////
	/// \brief generic update function
	///
	/// serves as container for all other update function/calls
	///
	/// \param target sf::RenderWindow* pointer to window in which object present
	/// \param _dt float* delta time value for which frame rate is adjusted
	/// \param _time_mult float* targeted value of fps
	/// for which frame rate independence is implemented
	///
	////////////////////////////////////////////////////////////
	void update(sf::RenderWindow* target, float* _dt, float* _time_mult);

	////////////////////////////////////////////////////////////
	/// \brief generic render function
	///
	/// serves as container for all other render functions/calls.
	///
	/// \param target sf::RenderWindow* pointer to window in 
	/// which object is to be rendered
	///
	////////////////////////////////////////////////////////////
	void render(sf::RenderWindow* target);

};

////////////////////////////////////////////////////////////
/// 
/// \class player
///
/// \brief class for the player
///
/// this class allows for the player's creation,movement,
/// input and collisions while also creating the trails which
/// colour the screen and the marker system which keeps track
/// of whether a level is completely coloured or not, along
/// with methods to add foresaid markers
///
////////////////////////////////////////////////////////////
#endif